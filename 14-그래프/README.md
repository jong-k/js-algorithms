# 그래프

## 그래프 개요

그래프 구성요소

- 유한하고 가변적인 정점, 노드, 점들의 집합(+ 연결도 표현)
  - 즉, 노드 혹은 노드들의 연결까지 포함
  - 트리(Tree)는 최소 2개의 정점이 연결된 그래프
- 방향 그래프의 경우: 정렬된 연결(연결된 정점들의 쌍으로 표현)
- 무방향 그래프의 경우: 정렬되지 않은 연결

그래프 사용 사례

- SNS에서 알 수도 있는 친구 추천
- 지도에서 길 찾기 기능

용어 정리

- 정점(Vertex): 노드
- 간선(Edge): 노드끼리의 연결
- 가중/비가중
  - Weighted(가중): 정점들의 연결(간선)에 값이 부여됨
    - 예) A부터 B 지점간의 거리
  - Unweighted(비가중): 간선에 값 없음
- 방향/무방향
  - Directed(방향): 정점들의 연결에 방향이 부여됨. 연결의 방향이 1개(A->B)
    - 예) 인스타그램 팔로우 관계
  - Undirected(무방향): 연결이 양방향(A-B)
    - 예) 페이스북 친구 관계

## 그래프 표현 방법

### 인접 행렬(Adjacency Matrix)

- 예시 (A~F 정점 간의 연결이 있으면 1, 없으면 0)

```js
//   A B C D E F
// A 0 1 0 0 0 1
// B 1 0 1 0 0 0
// C 0 1 0 1 0 0
// D 0 0 1 0 1 0
// E 0 0 0 1 0 1
// F 1 0 0 0 1 0
```

- 그래프 관계를 행렬로 나타낼 수 있다
  - boolean 기반 (0, 1)으로 연결 관계를 2차원 배열 형태로 표시

### 인접 리스트(Adjacency List)

- 예시

```js
[
  [1, 5], // 정점 0과 연결된 정점들
  [0, 2], // 정점 1과 연결된 정점들
  [1, 3],
  [2, 4],
  [3, 5],
  [0, 4],
];
```

- 그래프 관계를 이차원 배열로 나타낼 수 있다
  - 인덱스 0에는 정점 0과 연결된 정점들이 배열에 들어가 있음
- 위 그래프처럼 정점들이 숫자가 아닌 문자열이라면?
  - 해시 테이블을 사용한다
  - 예시

```js
{
  A: ['B', 'F'],
  B: ['A', 'E'],
  C: ['D', 'E'],
  D: ['C', 'F'],
  E: ['B', 'C'],
  F: ['A', 'D'],
}
```

### 인접 행렬과 인접 리스트의 시간 복잡도

- V : 정점(Vertex)의 갯수
- E : 간선(Edge)의 갯수

<table>
  <thead>
    <tr>
      <td>작업</td>
      <td>인접 리스트</td>
      <td>인접 행렬</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>정점 추가</td>
      <td>O(1)</td>
      <td>O(V^2)</td>
    </tr>
    <tr>
      <td>간선 추가</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>정점 제거</td>
      <td>O(V + E)</td>
      <td>O(V^2)</td>
    </tr>
    <tr>
      <td>간선 제거</td>
      <td>O(E)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>쿼리</td>
      <td>O(V + E)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>저장</td>
      <td>O(V + E)</td>
      <td>O(V^2)</td>
    </tr>
  </tbody>
</table>

#### 인접 리스트

- 공간을 덜 차지할 수 있다 (매우 큰 장점)
- 빠르게 모든 간선을 순회할 수 있다
- 특정 간선을 찾는데는 느림
- 현실 세계의 대부분의 데이터들은 밀도가 낮은 큰 그래프 형태이기 때문에 인접 리스트를 깊게 공부한다

#### 인접 행렬

- 공간을 더 많이 차지한다
- 간선을 확인하려면 모든 간선 순회 필요 (느림)
- 특정 간선을 찾는 것은 빠르다
- 밀집한 데이터를 다룰 때 좋다

### 그래프 구현

- 인접 리스트와 무방향 그래프 사용

addVertex(name): 정점의 이름을 인수로 받아 정점 생성

- 인접 리스트에 정점 프로퍼티 추가
  - key: name
  - value: []

addEdge(vertex1, vertex2): 정점 2개를 입력받아 간선 생성

- 인접 리스트에서 vertex1 프로퍼티(배열)에 vertex2를 추가
- 인접 리스트에서 vertex2 프로퍼티(배열)에 vertex1를 추가

removeEdge(vertex1, vertex2): 정점 2개를 입력받아 그 간선을 제거

- 인접 리스트의 vertex1 프로퍼티 배열에서 vertex2값 제거
- 인접 리스트의 vertex2 프로퍼티 배열에서 vertex1값 제거

removeVertex(vertex): 정점을 제거

- 정점 프로퍼티를 제거
- 정점과 관련된 모든 간선도 제거해야 함
  - 제거할 정점과 연결된 모든 정점을 순회하며 간선이 있는 경우 remove Edge 함수 실행
