# 그래프

> 그래프와 그래프 순회(DFS, BFS)

## 그래프 개요

그래프 구성요소

- 유한하고 가변적인 정점, 노드, 점들의 집합(+ 연결도 표현)
  - 즉, 노드 혹은 노드들의 연결까지 포함
  - 트리(Tree)는 최소 2개의 정점이 연결된 그래프 (+한 노드에서 다른 노드로 가는 경로가 유일)
- 방향 그래프의 경우: 정렬된 연결(연결된 정점들의 쌍으로 표현)
- 무방향 그래프의 경우: 정렬되지 않은 연결

그래프 사용 사례

- SNS에서 알 수도 있는 친구 추천
- 지도에서 길 찾기 기능

용어 정리

- 정점(Vertex): 노드
- 간선(Edge): 노드끼리의 연결
- 가중/비가중
  - Weighted(가중): 정점들의 연결(간선)에 값이 부여됨
    - 예) A부터 B 지점간의 거리
  - Unweighted(비가중): 간선에 값 없음
- 방향/무방향
  - Directed(방향): 정점들의 연결에 방향이 부여됨. 연결의 방향이 1개(A->B)
    - 예) 인스타그램 팔로우 관계
  - Undirected(무방향): 연결이 양방향(A-B)
    - 예) 페이스북 친구 관계

## 그래프 표현 방법

### 인접 행렬(Adjacency Matrix)

- 예시 (A~F 정점 간의 연결이 있으면 1, 없으면 0)

```js
//   A B C D E F
// A 0 1 0 0 0 1
// B 1 0 1 0 0 0
// C 0 1 0 1 0 0
// D 0 0 1 0 1 0
// E 0 0 0 1 0 1
// F 1 0 0 0 1 0
```

- 그래프 관계를 행렬로 나타낼 수 있다
  - boolean 기반 (0, 1)으로 연결 관계를 2차원 배열 형태로 표시

### 인접 리스트(Adjacency List)

- 예시

```js
[
  [1, 5], // 정점 0과 연결된 정점들
  [0, 2], // 정점 1과 연결된 정점들
  [1, 3],
  [2, 4],
  [3, 5],
  [0, 4],
];
```

- 그래프 관계를 이차원 배열로 나타낼 수 있다
  - 인덱스 0에는 정점 0과 연결된 정점들이 배열에 들어가 있음
- 위 그래프처럼 정점들이 숫자가 아닌 문자열이라면?
  - 해시 테이블을 사용한다
  - 예시

```js
{
  A: ['B', 'F'],
  B: ['A', 'E'],
  C: ['D', 'E'],
  D: ['C', 'F'],
  E: ['B', 'C'],
  F: ['A', 'D'],
}
```

### 인접 행렬과 인접 리스트의 시간 복잡도

- V : 정점(Vertex)의 갯수
- E : 간선(Edge)의 갯수

<table>
  <thead>
    <tr>
      <td>작업</td>
      <td>인접 리스트</td>
      <td>인접 행렬</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>정점 추가</td>
      <td>O(1)</td>
      <td>O(V^2)</td>
    </tr>
    <tr>
      <td>간선 추가</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>정점 제거</td>
      <td>O(V + E)</td>
      <td>O(V^2)</td>
    </tr>
    <tr>
      <td>간선 제거</td>
      <td>O(E)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>쿼리</td>
      <td>O(V + E)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>저장</td>
      <td>O(V + E)</td>
      <td>O(V^2)</td>
    </tr>
  </tbody>
</table>

#### 인접 리스트

- 공간을 덜 차지할 수 있다 (매우 큰 장점)
- 빠르게 모든 간선을 순회할 수 있다
- 특정 간선을 찾는데는 느림
- 현실 세계의 대부분의 데이터들은 밀도가 낮은 큰 그래프 형태이기 때문에 인접 리스트를 깊게 공부한다

#### 인접 행렬

- 공간을 더 많이 차지한다
- 간선을 확인하려면 모든 간선 순회 필요 (느림)
- 특정 간선을 찾는 것은 빠르다
- 밀집한 데이터를 다룰 때 좋다

## 그래프 구현

- 인접 리스트와 무방향 그래프 사용

addVertex(name): 정점의 이름을 인수로 받아 정점 생성

- 인접 리스트에 정점 프로퍼티 추가
  - key: name
  - value: []

addEdge(vertex1, vertex2): 정점 2개를 입력받아 간선 생성

- 인접 리스트에서 vertex1 프로퍼티(배열)에 vertex2를 추가
- 인접 리스트에서 vertex2 프로퍼티(배열)에 vertex1를 추가

removeEdge(vertex1, vertex2): 정점 2개를 입력받아 그 간선을 제거

- 인접 리스트의 vertex1 프로퍼티 배열에서 vertex2값 제거
- 인접 리스트의 vertex2 프로퍼티 배열에서 vertex1값 제거

removeVertex(vertex): 정점을 제거

- 정점 프로퍼티를 제거
- 정점과 관련된 모든 간선도 제거해야 함
  - 제거할 정점과 연결된 모든 정점을 순회하며 간선이 있는 경우 remove Edge 함수 실행

## 그래프 순회

### 그래프 순회 활용 사례

- peer to peer networking
  - 알 수도 있는 친구를 추천할 때
  - 한 다리 건너면 아는 친구면, 그래프로 가는 경로가 짧음
- web crawlers
- finding "closest" matches/recommendations
- shortest path problems
  - GPS Navigation
  - Solving mazes
  - AI (shortest path to win the game)

### DFS

#### 인접리스트에서 DFS 순회 살펴보기

- 예시

```js
// 인접 리스트
{
  'A': ['B', 'C'],
  'B': ['A', 'D'],
  'C': ['A', 'E'],
  'D': ['B', 'E', 'F'],
  'E': ['C', 'D', 'F'],
  'F': ['D', 'E']
}
/* 순회 순서 (알파벳 순으로 한다고 가정)
1. A를 방문하고 간선들에서 A를 모두 지움 (B,C에 포함된 A 제거)
2. A에서 가장 빠른 알파벳인 B를 방문하고 제거 (A, D에 포함된 B 제거)

중간 점검
  'A': ['C'],
  'B': ['D'],
  'C': ['E'],
  'D': ['E', 'F'],
  'E': ['C', 'D', 'F'],
  'F': ['D', 'E']

3. B에서 가장 빠른 알파벳인 D를 방문하고 제거 (B의 D는 이미 제거됨, E의 D 제거)
4. D에서 가장 빠른 알파벳인 E를 방문하고 제거 (C의 E, F의 E)

중간 점검
  'A': ['C'],
  'B': [],
  'C': [],
  'D': ['F'],
  'E': ['C', 'F'],
  'F': []

5. E에서 가장 빠른 C 방문하고 제거 (A의 C, E의 C)
6. C에 남은 원소 없음 (막다른 길) -> 이전의 E로 되돌아감 -> F 방문하고 제거

최종
  'A': [],
  'B': [],
  'C': [],
  'D': [],
  'E': [],
  'F': []

 */
```

#### 구현

recursiveDFS(start): 재귀 DSF 방식으로 그래프의 모든 정점을 방문하고 배열에 담아서 반환

- 스타팅 노드를 인수로 받는다
- 최종 방문 결과를 저장할 result 배열을 만든다
- 정점 방문 여부를 저장하는 visited 객체를 만든다
- 실제 재귀호출될 헬퍼 함수 생성 (정점을 인수로 받음)
  - 인접리스트의 정점 프로퍼티가 없으면 early return (base case)
  - 인수로 받은 정점을 방문 처리(배열과 객체에 저장)
  - 인접 리스트의 모든 값들을 순회하고 아직 방문되지 않은 값이 있으면 그 정점을 인수로 재귀호출
- 방문 배열 반환

iterativeDFS(start): 반복 DFS 방식으로 그래프의 모든 정점을 방문하고 배열에 담아서 반환

- start 노드를 인수로 받는다
- 정점을 추적할 용도의 스택(배열) 생성하고 start 변수 넣음
- 방문 여부를 기록할 visited 객체 생성하고 start 방문 처리
- 방문 순서를 기록할 result 배열 생성
- 스택에 원소가 있는 동안 아래 반복
  - 스택의 원소(정점) pop
  - 정점이 아직 방문되지 않았다면
    - visited 에서 방문 처리
    - result 배열에 정점 추가
    - 인접 리스트에서 연결된 정점들을 스택에 모두 추가

### BFS

- BFS는 반복으로만 구현한다 (재귀로 구현할 수 없음)
- 스택을 사용하는 반복형 DFS를 큐를 사용하게 변경하면 됨

BFS(start): 그래프의 모든 정점을 방문하고 배열에 담아서 반환

- start 노드를 인수로 받는다
- 정점을 추적할 용도의 큐(배열) 생성하고 start 변수 넣음
- 방문 여부를 기록할 visited 객체 생성하고 start 방문 처리
- 방문 순서를 기록할 result 배열 생성
- 큐에 원소가 있는 동안 아래 반복
  - 큐의 원소(정점) shift
  - 정점이 아직 방문되지 않았다면
    - visited 에서 방문 처리
    - result 배열에 정점 추가
    - 인접 리스트에서 연결된 정점들을 큐에 모두 추가
