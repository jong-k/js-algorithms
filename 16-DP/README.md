# 동적 프로그래밍(Dynamic Programming)

복잡한 문제를 더 간단한 하위의 문제의 모음으로 쪼개고 각 하위 문제들을 풀어서 그 답을 저장하는 방식으로 문제를 푸는 방법

## 개요

- 1940년대에 리차드 벨만이 고안한 개념
- 컴퓨터와 관계없는 군대에서의 최적화 계획을 위해서 만든 개념

## DP로 해결할 수 있는 문제 패턴

### 1. Overlapping Subproblems (반복되는 하위 문제들)

피보나치 수열

- 피보나치 수열의 5번째 숫자를 구한다면, 아래처럼 task를 쪼갤 수 있다

```js
/*                             fib(5)

                       fib(4)    +       fib(3)
                
               fib(3)  +   fib(2)     fib(2)  +  fib(1)
               
       fib(2)   +  fib(1)     
*/
```

### 2. Optimal Substructure (최적 부분 구조)

- 5번째 피보나치 수를 찾는 최적의 해답은 4번째 + 3번째 피보나치 수를 더하는 것이다
- 또한 빠른 길 찾기 문제의 최적부분구조를 찾으면
  - A -> D 빠른 길은
    - A -> C 빠른 길 + C -> D 빠른 길 합친 것과 똑같다

## 재귀 함수 솔루션과 그 문제점

- ./recursiveFib.js

피보나치 수열 문제를 재귀 함수로 풀면

- fib(n) 이 증가할 수록 엄청난 크기의 트리가 생김
  - fib(1), fib(2) 이외에는 매번 직접 계산해야 함
- 간단하지만, 시간 복잡도가 매우 크게 증가 => O(2^N)
  - 실제로는 O(1.6^N) 정도이나 그냥 2의 제곱으로 친다
- fib(3), fib(4) 등의 기초 작업을 한번만 해두고 결과를 저장해서 활용하면 복잡도를 낮출 수 있다

## 재귀 + 메모이제이션 (Top-down)

memo 배열을 활용하여 지난 연산값을 저장

- 시간 복잡도를 O(2^N) 에서 O(N) 으로 낮출 수 있다

## 반복 + 메모이제이션 (Tabulation)

./iterativeFib.js

- 연산 결과를 테이블(주로 배열)에 저장하기 때문에 tabulation 이라는 이름을 가짐
- 보통 반복문을 사용
- 더 나은 공간 복잡도를 가진다 (시간복잡도는 O(N)으로 동일)
