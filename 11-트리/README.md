# 트리

> 이진 탐색 트리, 트리 순회(BFS, DFS)

## 1. 트리 기초

### 특징

비선형(non-linear) 자료구조

- 리스트와 다르게 비선형 자료구조이다

parent-child 관계

- 노드들 간 부모-자식 관계를 갖는다
- 부모 노드는 자식 노드만 가리킬 수 있다 (형제 노드를 가리켜서도 안됨)

시작지점(entry point)

- 시작지점이 단 하나여야 한다 (루트 노드)

사이클이 없어서 모든 경로가 유일하다

### 주요 용어

- Root : 최상위 노드
- Child : Root에서 내려와 다른 노드로부터 연결된 노드
- Parent : Child의 상위 노드
- Siblings : 같은 Parent를 가진 노드
- Leaf : Child가 없는 노드
- Edge (간선) : 한 노드와 다른 노드 간의 연결

### 트리 활용 예시

- HTML DOM: DOM Tree 구조
- 네트워크 라우팅
- 추상구문트리 (Abstract Syntax Tree): 프로그래밍 언어의 구문을 설명
- 파일 시스템의 디렉토리 구조

### 트리 종류

이진 트리(Binary Tree)

- 부모 노드가 최대 2개까지만 자식 노드를 가질 수 있음

이진 탐색 트리(Binary Search Tree)

- 탐색에 강점을 갖게 설계된 이진 트리
- 데이터를 비교해서 정렬해서 저장
- 값들이 모두 unique하다
- 부모 노드의 왼쪽 자식 노드는 부모 노드보다 작고
- 부모 노드의 오른쪽 자식 노드는 부모 노드보다 크다
- 예시

```js
// 이진 탐색 트리

//        10
//      /   \
//     6    15
//   /  \     \
//  3    8     20
```

### 이진 탐색 트리 탐색 과정

아래 이진탐색트리에서 72를 찾아나가는 과정은 어떻게 될까?

```js
//             41
//         /        \
//      20            65
//    /    \        /    \
//  11     29     50       91
//    \      \           /    \
//     12    32        72      99
```

1. 72는 41보다 큰가? (O) -> 우측 자식 노드(65)로 이동 (좌측 절반 날아감) -> 이진 탐색과 유사
2. 72는 65보다 큰가? (O) -> 우측 자식 노드(91)로 이동
3. 72는 91보다 큰가> (X) -> 좌측 자식 노드(71)로 이동 -> 소요된 연산 : 3회

### 이진 탐색 트리 구현

insert(val): 새 노드를 생성하고 트리에 추가하고 트리를 반환

- 반복, 재귀 방식으로 구현 가능
- 노드를 생성한다
  - root 노드가 없으면, 새 노드를 root 노드로 설정
- 새 노드와 root 노드를 비교한다
  - root 노드가 새 노드보다 크면, root 우측 자식 노드가 있는지 확인하고
    - 우측 자식 노드가 있으면 다시 비교
    - 없으면 우측 자식 노드 자리에 위치
  - root 노드가 새 노드보다 작으면, root 좌측 자식 노드가 있는지 확인하고
    - 좌측 자식 노드가 있으면 다시 비교
    - 없으면 좌측 자식 노드 자리에 위치

find(val): value값을 입력받아 해당 값이 트리에 있는지 여부를 반환

- 반복, 재귀 방식으로 구현 가능
- root 노드가 없으면 undefined 반환
- root 노드가 있으면 값 비교
  - 찾는 값이면 탐색을 종료
  - value 값이 root 값보다 더 크면 우측 자식 노드 있는지 확인
    - 우측 노드 없으면 탐색 종료
    - 우측 노드 있으면 우측 노드로 이동해 대소 비교
  - value 값이 root 값보다 더 작으면 좌측 노드 있는지 확인
    - 좌측 노드 없으면 탐색 종료
    - 좌측 노드 있으면 좌측 노드로 이동해 대소 비교

### BST 시간 복잡도

- 삽입 : O(log N) -> best, average
- 탐색 : O(log N)
- log N 의 시간복잡도는 매우 우수한 편이다!
- 하지만 worst case도 존재한다
  - 예) 3 - 17 - 19 - 32 - 34 - ... 처럼 한 방향으로만 늘어지는 형태
  - 복잡도가 깊이만큼 증가 : O(N)

## 2. 트리 순회(Tree Traversal)

### 트리 순회 방법

- 모든 트리 형태에 사용할 수 있어야 한다 (굳이 이진 트리가 아니어도 사용 가능해야 한다)
- 모든 트리의 노드를 한번씩 방문하는 방법
  - 너비 우선 탐색(BFS - Breadth First Search)
  - 깊이 우선 탐색(DFS - Depth First Search)
- 예시

  ```js
  //        10
  //      6    15
  //   3   8       20
  ```

방법 1. BFS

- 트리를 수평으로 순회 (형제 노드끼리 수평으로 움직임)
- 예) 10 -> 6 -> 15 -> 3 -> 8 -> 20

방법 2. DFS

- 트리를 수직으로 순회 (수직으로 내려갔다가 다시 올라옴)
- 3가지 방법이 있음(전위, 중위, 후위)
- 전위 탐색 DFS 예) 10 -> 6 -> 3 -> 8 -> 15 -> 20

### BFS 구현

- 반복문 방식을 사용
- 배열(or 큐)을 생성하고 방문한 노드를 저장할 변수(visited) 생성
- 루트 노드를 큐에 삽입
- 큐에 노드가 있을 동안 아래를 반복
  - 큐에서 노드를 dequeue하고 노드의 값을 배열(or 큐)에 저장
  - dequeue된 노드의 좌측 자식 노드가 있는지 확인하고 있으면 큐에 삽입
  - dequeue된 노드의 우측 자식 노드가 있는지 확인하고 있으면 큐에 삽입
- 루프가 끝나면 모든 값이 담긴 배열 반환

### DFS

#### 전위, 후위, 중위 비교

```js
//        10
//      6    15
//   3   8       20
```

3가지 탐색으로 나눌 수 있음

- 전위 탐색 : [10, 6, 3, 8, 15, 20]
  - 깊이 상관없이 제일 왼쪽 먼저, 오른쪽은 그 다음 (부모 먼저)
  - 사용 예시: 폴더 구조를 통째로 복사할 때, 부모 폴더를 먼저 만들고 하위 내용을 기록해야 할 때
- 후위 탐색 : [3, 8, 6, 20, 15, 10]
  - 왼쪽, 오른쪽 순으로 자식 노드를 방문하고, 모든 자식 노드를 방문하고 나서야 부모 노드 방문
  - 사용 예시: 트리 구조의 폴더를 통째로 삭제할 때, 하위부터 지우고 부모 폴더 지우기
- 중위 탐색 : [3, 6, 8, 10, 15, 20]
  - 왼쪽 자식 노드 -> 부모 노드 -> 오른쪽 자식 노드 순으로 방문
  - 사용 예시: 트리 내용을 오름차순으로 배열에 담아 출력할 때 사용

3가지 탐색 방법은 방문 노드를 기록하는 시점만 약간 다르고 구조는 비슷함

#### 전위 탐색(Pre Order) DFS 구현

- 재귀 함수 방식을 사용하여 구현
- 방문할 노드를 저장할 변수 visited 생성
- 루트 노드를 current 변수에 할당
- 노드를 인수로 받는 traverse 헬퍼 함수 생성
  - visited 배열에 방문한 node 값을 push (순서 중요)
  - 노드에 좌측 자식 노드가 있으면 헬퍼 함수를 재귀 호출(좌측 자식 노드를 인수로 전달)
  - 노드에 우측 자식 노드가 있으면 헬퍼 함수를 재귀 호출(우측 자식 노드를 인수로 전달)
- visited 배열 반환

#### 후위 탐색(Post Order) DFS 구현

- 재귀 함수 방식을 사용하여 구현
- 방문할 노드를 저장할 변수 visited 생성
- 루트 노드를 current 변수에 할당
- traverse 헬퍼 함수생성
  - 노드에 좌측 자식 노드가 있으면 헬퍼 함수를 재귀 호출(좌측 자식 노드를 인수로 전달)
  - 노드에 우측 자식 노드가 있으면 헬퍼 함수를 재귀 호출(우측 자식 노드를 인수로 전달)
  - visited 배열에 방문한 node 값을 push (순서 중요)
- visited 배열 반환

#### 중위 탐색(In Order) DFS 구현

- 재귀 함수 방식을 사용하여 구현
- 방문할 노드를 저장할 변수 visited 생성
- 루트 노드를 current 변수에 할당
- traverse 헬퍼 함수생성
  - 노드에 좌측 자식 노드가 있으면 헬퍼 함수를 재귀 호출(좌측 자식 노드를 인수로 전달)
  - visited 배열에 방문한 node 값을 push (순서 중요)
  - 노드에 우측 자식 노드가 있으면 헬퍼 함수를 재귀 호출(우측 자식 노드를 인수로 전달)
- visited 배열 반환

### BFS, DFS를 언제 사용할까?

일반적으로 시간 복잡도는 동일하다 (모든 노드를 방문하기 때문에)

- BFS는 큐를 사용하게 된다 (자식노드를 먼저 방문하지 않음)
- 그래서 트리의 Depth가 깊어지면 큐에 필요한 메모리가 증가하게 된다 (공간복잡도 증가)

한 쪽으로 치우친 트리

- BFS를 사용하면 큐에 저장할 데이터가 적어서 부담이 덜하다

노드가 수평으로 길게 구성된 트리

- BFS는 로직 특성상 큐에 노드를 저장 => 공간 복잡도 증가
- DFS를 사용하면 leaf까지 한번씩 쓱 훑으면 되서 유리

이진 탐색 트리에서 중위 탐색 DFS를 사용하면 데이터를 오름차순으로 정렬할 수 있음

## 3. 기타 알고리즘

### LCA (Lowest Common Ancestor) 찾기

최소 공통 조상 찾기

- 이진 트리와 트리에 속한 두 노드가 주어질 때, 두 노드의 최소 공통 조상 찾기
- 예시

```js
//         1
//       /   \
//      2     3
//     / \   / \
//    4   5 6   7
// LCA(4,5) -> 2
// LCA(2,4) -> 2
// LCA(5,3) -> 1
```

findLCA() 구현 (leaf 에서 시작해보면 이해 잘됨)

- 루트 노드에서 시작
- 루트 노드가 node1 or node2 이면 루트 노드 반환
- 아니라면 왼쪽과 오른쪽 서브트리 탐색(재귀 호출)
  - 현재 노드와 왼쪽 자식 노드를 대상으로 findLCA 재귀호출
  - 현재 노드와 오른쪽 자식 노드를 대상으로 findLCA 재귀호출
- 현재 노드의 왼쪽과 오른쪽 자식 노드가 모두 찾을 노드라면 현재 루트 노드가 LCA
- 그렇지 않고 한쪽에서만 발견되면 발견된 노드가 LCA
  - 발견되지 않은 반대쪽은 아예 관련 없다는 뜻이므로

시간 복잡도

- O(N): 모든 노드를 1번씩 방문하므로

### 트리의 지름(diameter) 구하기

- 간선이 거리(가중치)를 갖는 트리라고 가정.
- 트리의 지름: 임의의 두 점 사이의 거리의 최댓값

트리의 지름 구하는 방법

- 아무 노드에서 가장 먼 정점을 찾고, 가장 먼 정점에서 다시 가장 먼 정점을 찾는다
- 트리에서 임의의 노드 X에서 가장 먼 노드는 A의 지름의 끝점이다

이유

- 트리는 사이클이 없어서 모든 경로가 유일
- 만약, 지름의 양 끝이 P, Q라면, 임의의 점 X에서 가장 먼 점 A는 P 또는 Q 중 하나이다

구현

- ./solutions/getTreeDiameter.js
