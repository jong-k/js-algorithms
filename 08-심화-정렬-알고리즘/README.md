# 심화 정렬 알고리즘

> 합병, 퀵, 기수 정렬

## 0. 인트로

- 기본 정렬 알고리즘: O(N^2)
  - 작은 규모의 데이터셋에서만 효율적(10만 개 원소 이하)
- 심화 정렬 알고리즘: O(N\*logN)
  - 버블, 삽입, 선택 정렬보다 복잡하지만 더 빠름

## 1. 합병 정렬 (Merge Sort)

- 폰 노이만이 EDVAC 컴퓨터로 1948년 처음 개발
- 분할, 정렬, 합병이 동시 발생
- 원소 1개의 배열은 정렬되어 있는 점을 활용
- 원소 N개가 있는 배열을 계속 분할하여 길이가 1개인 배열 N개로 분할
- 그리고 합병과 정렬을 반복
- 동작 예시

```js
// [3 44 38 5 47 15 36 26]
// [3] [44] [38] [5] [47] [15] [36] [26]
// [3 44] [38] [5] [47] [15] [36] [26]
// [3 44] [5 38] [47] [15] [36] [26]
// [3 5 38 44] [47] [15] [36] [26]
// [3 5 38 44] [15 47] [36] [26]
// [3 5 38 44] [15 47] [26 36]
// [3 5 38 44] [15 26 36 47]
// [3 5 15 26 36 38 44 47]
```

### 배열 합병을 담당하는 로직

- 배열은 정렬되어 있다고 전제
- 예시

```js
// 이러한 합병 함수가 있다고 가정하면
merge([1, 10, 50], [2, 14, 99, 100]); // [1, 2, 10, 14, 50, 99, 100]
```

- 주어진 두 배열을 하나의 정렬된 배열로 만드는데, 두 배열의 모든 원소가 포함되어 있어야 한다
- 시간복잡도와 공간복잡도는 O(N + M) 으로 작동해야 한다 (두 배열의 길이의 합)

구현

- 최종 정렬할 빈 배열을 먼저 선언
- 왼쪽 배열, 오른쪽 배열의 현재 인덱스를 가리킬 변수 2개 선언
- 비교가 필요할 때의 while문에서는 각 맨 앞 인덱스를 비교후 작은 값을 빈 배열에 넣고, 그 인덱스 +1
- 한 쪽 배열의 원소가 모두 없어지면, 나머지 반대쪽의 원소를 전부 그대로 빈 배열에 push

### 전체 합병 정렬 로직

- 배열을 절반으로 나눠나가기 위해 slice()를 사용
  - 전체 길이를 기준으로 절반으로 쪼개서 재귀 호출
- 최종 배열들의 길이는 1보다 작거나 같아야 함(base case)
- 이렇게 작은 배열이 준비되면 작성해놓은 합병 함수를 사용하여 합병

```js
// 10 24 76 73 72 1 9
// L [10 24 76]  // R [73 72 1 9]
// L [10] R [24 76] // L [73 72] R [1 9]
// [10], [24], [76], [73], [72], [1], [9] -> 완성
```

- 이제 이 배열들이 merge 함수를 통해 합병되면서 정렬됨

구현

- ./mergeSort.js

### 시간 복잡도

- 합병 정렬은 엣지 케이스가 없고 어떤 상태에서든지 같은 효율을 보여준다.
- best : O(N logN)
- average : O(N logN)
- worst : O(N logN)
- 공간복잡도 : O(N)

```js
32
16 16
8 8 8 8
4 4 4 4 4 4 4 4
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

// 분할하는데 32의 경우 5회 걸린다 O(logN)
// 각 분할마다, merge 함수로 합병할 때 O(N)의 시간 복잡도 소요됨 (사실은 O(N+M)번)
// 그래서 총 시간 복잡도는 O(N logN)
```

## 2. 퀵 정렬 (Quick Sort)

- 합병 정렬과 마찬가지로 재귀를 활용해 배열에 0 또는 1개의 원소가 남을 때 까지 분할하고 정렬
  - 1개의 원소로 이루어진 배열은 항상 정렬되어 있다는 개념 활용
- 하나의 요소(pivot) 를 골라 배열 전체에서의 자리를 잡는 방식

동작 원리

```js
// 5 2 1 8 4 7 6 3 (시작)
//
//         5 -> 5의 위치는 구했음 (고정)
// 3 2 1 4   7 6 8 (시행1) -> 1. 2.
//
//         5
//     3
// 1 2   4   7 6 8 (시행2) -> 3.

// 1. 맨 첫번째 숫자 5를 고르고, 5보다 작은 숫자를 5 왼쪽으로 옮기고,
// 2. 큰 숫자는 5 오른쪽으로 옮김
// 3. 이제 이 과정을 왼쪽과 오른쪽에서 재귀적으로 반복
```

### pivot 헬퍼 함수 구현

- 배열이 주어지면 어떤 요소를 pivot으로 지정
- pivot 보다 작은 값은 모두 pivot보다 왼쪽으로, 큰 값은 pivot의 오른쪽으로 이동하도록 배열 재정렬
  - 이 때, 이동하는 요소들의 순서는 중요하지 않음
- 헬퍼는 이 작업을 수행할 때 새 배열을 만들면 안됨
- 분류가 완료되면 pivot 인덱스를 반환

pivot 선택

- 퀵 정렬의 실행 시간은 pivot 선택 방법에 따라 미세하게 달라진다
- 제일 이상적인 pivot의 위치는 정렬하려는 데이터의 대략적인 중앙값
  - 우선은 제일 간단하게 첫 번째 요소를 pivot으로 선택

pivot 헬퍼 함수 구현

- 매개변수 설정: array, start index(0), end index(array.length - 1)
- 배열 첫 원소를 pivot으로 설정
- 현재 pivot의 인덱스를 변수에 저장(pivot이 끝나야 하는 위치를 추적)
- 배열 처음부터 끝까지 순회하면서
  - pivot이 현재 원소보다 크면, pivot 인덱스 변수를 증가하고, 현재 원소와 pivot 인덱스의 원소를 교환
- 시작 원소와 pivot 인덱스의 원소를 교환
- pivot 인덱스 반환

### 퀵 정렬 구현

- pivot 헬퍼 함수를 배열에 호출하여 pivot 인덱스 획득
- pivot index 양측을 재귀호출하여 전체 배열 정렬

### 시간 복잡도

- Best : O(N log N)
- Average : O(N log N)
- Worst : O(N^2)
- 공간 복잡도 : O(log N)

합병 정렬처럼, N이 늘어나면 밑이 2인 log N의 분해가 수행되는 패턴

- 예) pivot 인덱스가 정해지면 앞뒤로 quickSort 재귀적 호출 -> 32개 배열에서는 5회 시행
- 즉, N번마다 log N 시행

### 만약, [1 2 3 4 5] 처럼 정렬된 배열에 수행되면?

- 피벗 포인트를 맨 처음으로 잡으면 피벗 인덱스가 스타팅 포인트가 된다
- 이러면 좌 우로 퀵 정렬 재귀 호출이 불가능해지고 (왼쪽이 빈배열)
- N번의 수행이 필요하게 된다 (log N번이 아닌)
- 따라서 정렬된 배열에서는 계속 중간값을 피벗 포인트로 잡아야 한다

## 3. 기수 정렬 (Radix Sort)

### 기수 정렬과 다른 정렬의 차이점

- 지금까지 등장한 일반적인 정렬 방법은 모두 비교 정렬 방식
- 하지만, 수학적 측면에서 봤을 때, 비교 정렬의 평균적인 시간 복잡도에는 하한선과 점근선이 존재
- 이 제약조건들로 인해 비교 정렬은 빨라야 최대 O(N logN)까지만 빨라질 수 있음
- 기수 정렬은 원소들간의 대소 비교 대신, 자릿수를 가림

### 기수 정렬 개요

- 숫자 리스트에 대해서만 사용할 수 있음(숫자의 자릿수를 갖고 정렬하기 때문에)
- 값의 직접 비교 대신 자릿수를 비교

  - 숫자의 자릿수로 크기를 알 수 있는 것을 활용
  - 자릿수가 클(많을)수록 더 큰 숫자임

### 작동 원리

```js
// 1556, 4, 3556, 593, 408, 4386, 902, 7, 8157, 86, 9637, 29
// 10진수 이므로 버켓 10개 (0~9)
// 1의 자리부터, 자릿수를 기준으로 버켓에 정렬한다

// 1) 1의 자릿수로 정렬 (차례대로 버켓에 넣는다)
// 0 1   2   3 4 5    6    7   8  9
//     902 593 4     86 9637 408 29
//                 4386 8157
//                 3556    7
//                 1556

// 이를 바탕으로 재정렬 (같은 버켓이면 먼저 들어간 수가 먼저 나온다)
// 902, 593, 4, 1556, 3556, 4386, 86, 7, 8157, 9637, 408, 29

// 2) 10의 자릿수로 정렬
//  0   1   2     3   4    5    6  7    8    9
// 408      29  9637     8157           86  593
//   7                   3556         4386
//   4                   1556
// 902

// 정렬
// 902, 4, 7, 408, 29, 9637, 8157, 3556, 1556, 4386, 86, 593

// 3) 100의 자릿수로 정렬
// 0     1    2  3    4    5    6  7    8    9
//  86  8157    4386  408  593 9637          902
//  29                    3556
//   7                    1556
//   4

// 정렬
// 4 7 29 86 8157 4386 408 1556 3556 593 9637 902

// 마지막) 1000의 자릿수로 정렬
// 0     1    2  3     4     5   6  7  8     9
//  902  1556    3556  4386            8157  9637
//  593
//  408
//   86
//   29
//    7
//    4

//  정렬
// 4 7 29 86 408 593 902 1556 3556 4386 8157 9637
```

### 구현

- 모든 숫자의 배열을 받는 함수 선언
- 배열에서 가장 큰 수가 가진 자릿수를 확인
- 0부터 최대 자릿수까지 반복

  - 0부터 9까지의 각 자릿수의 숫자에 해당하는 버킷(2차원 배열)을 생성
  - 각 숫자를 자릿수별 숫자에 해당하는 버킷에 삽입
  - 버킷의 순서를 유지하며 값들을 배열로

### 기수 정렬의 시간복잡도

n은 배열의 길이, k는 자릿수

- Best: O(nk)
- Average: O(nk)
- Worst: O(nk)
- 공간복잡도: O(n + k)

시간 복잡도

- 자릿수의 영향을 크게 받는것을 알 수 있다
- 그러나 컴퓨터가 숫자 정보를 저장하는 방식 때문에 자연적인 무작위한 데이터상에서는 k가 실제로 log n에 가깝게 된다
- 즉, 비교 정렬과 복잡도 차이가 크지 않게 되버린다
