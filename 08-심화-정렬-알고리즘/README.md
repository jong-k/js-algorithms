# 심화 정렬 알고리즘

> 합병, 퀵, 기수 정렬

## 0. 인트로

- 기본 정렬 알고리즘: O(N^2)
  - 작은 규모의 데이터셋에서만 효율적(10만 개 원소 이하)
- 심화 정렬 알고리즘: O(N\*logN)
  - 버블, 삽입, 선택 정렬보다 복잡하지만 더 빠름

## 1. 합병 정렬 (Merge Sort)

- 폰 노이만이 EDVAC 컴퓨터로 1948년 처음 개발
- 분할, 정렬, 합병이 동시 발생
- 원소 1개의 배열은 정렬되어 있는 점을 활용
- 원소 N개가 있는 배열을 계속 분할하여 길이가 1개인 배열 N개로 분할
- 그리고 합병과 정렬을 반복
- 동작 예시

```js
// [3 44 38 5 47 15 36 26]
// [3] [44] [38] [5] [47] [15] [36] [26]
// [3 44] [38] [5] [47] [15] [36] [26]
// [3 44] [5 38] [47] [15] [36] [26]
// [3 5 38 44] [47] [15] [36] [26]
// [3 5 38 44] [15 47] [36] [26]
// [3 5 38 44] [15 47] [26 36]
// [3 5 38 44] [15 26 36 47]
// [3 5 15 26 36 38 44 47]
```

### 배열 합병을 담당하는 로직

- 배열은 정렬되어 있다고 전제
- 예시

```js
// 이러한 합병 함수가 있다고 가정하면
merge([1, 10, 50], [2, 14, 99, 100]); // [1, 2, 10, 14, 50, 99, 100]
```

- 주어진 두 배열을 하나의 정렬된 배열로 만드는데, 두 배열의 모든 원소가 포함되어 있어야 한다
- 시간복잡도와 공간복잡도는 O(N + M) 으로 작동해야 한다 (두 배열의 길이의 합)

구현

- 최종 정렬할 빈 배열을 먼저 선언
- 왼쪽 배열, 오른쪽 배열의 현재 인덱스를 가리킬 변수 2개 선언
- 비교가 필요할 때의 while문에서는 각 맨 앞 인덱스를 비교후 작은 값을 빈 배열에 넣고, 그 인덱스 +1
- 한 쪽 배열의 원소가 모두 없어지면, 나머지 반대쪽의 원소를 전부 그대로 빈 배열에 push

### 전체 합병 정렬 로직

- 배열을 절반으로 나눠나가기 위해 slice()를 사용
  - 전체 길이를 기준으로 절반으로 쪼개서 재귀 호출
- 최종 배열들의 길이는 1보다 작거나 같아야 함(base case)
- 이렇게 작은 배열이 준비되면 작성해놓은 합병 함수를 사용하여 합병

```js
// 10 24 76 73 72 1 9
// L [10 24 76]  // R [73 72 1 9]
// L [10] R [24 76] // L [73 72] R [1 9]
// [10], [24], [76], [73], [72], [1], [9] -> 완성
```

- 이제 이 배열들이 merge 함수를 통해 합병되면서 정렬됨

구현

- ./mergeSort.js

### 시간 복잡도

- 합병 정렬은 엣지 케이스가 없고 어떤 상태에서든지 같은 효율을 보여준다.
- best : O(N logN)
- average : O(N logN)
- worst : O(N logN)
- 공간복잡도 : O(N)

```js
32
16 16
8 8 8 8
4 4 4 4 4 4 4 4
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

// 분할하는데 32의 경우 5회 걸린다 O(logN)
// 각 분할마다, merge 함수로 합병할 때 O(N)의 시간 복잡도 소요됨 (사실은 O(N+M)번)
// 그래서 총 시간 복잡도는 O(N logN)
```
