# 트라이(Trie)

- 문자열이나 키-값 쌍을 효율적으로 저장하고 검색하기 위한 트리 형태의 자료구조
- 주로 문자열 검색, 자동 완성, 사전 구현 등에 사용됨

## 구조

- 각 노드는 문자를 나타내며, 루트 노드에서 시작해 각 경로가 문자열을 형성
- 노드는 자식 노드들(다음 문자)과 연결되며, 현재 노드가 단어의 끝임을 표시하는 플래그(예: isEndOfWord)를 가질 수 있음
- 예시

```js
/*
Trie에 apple, app, ape 단어들이 존재한다면
        a
        p
(true)      
    e     p(isEndOfWord true)
          l
          e(true)
*/
```

## 장점

- 문자열 검색이 빠르다
  - O(m): m은 문자열의 길이
- 접두사 기반 검색에 효율적
  - 예: "ca" 로 "car", "cat" 빠르게 검색 가능
- 메모리를 공유하여 중복 접두사를 줄일 수 있다

## 단점

- 메모리 사용량이 많을 수 있다 (각 문자마다 노드가 필요)
  - 공간 복잡도: O(n \* m)
    - n: 단어 수
    - m: 평균 단어 길이
- 구현이 다소 복잡

## 사용 예시

- 자동 완성 기능
  - 예: 검색창에 "ap" 입력 시 "app", "apple" 제안
- 사전에서 단어 유효성 검사

## 구현

### insert(word): 문자열을 Trie에 삽입

- 문자열을 순회하며 각 문자가 없으면, 문자를 키값으로 하여 새 자식 노드를 생성
- leaf 노드에서 isEndOfWord 프로퍼티를 true로 설정
- O(m): m은 문자열의 길이

### search(word): 주어진 문자열이 Trie에 존재하는지 확인

- 문자열을 순회하며 노드가 존재하는지 확인하고, 마지막 노드의 isEndOfWord 값이 true 인지 확인
- O(m): m은 문자열의 길이

### startsWith(prefix): 주어진 문자열(접두사)로 시작하는 단어가 Trie에 있는지 확인

- 문자열을 순회하며 노드가 존재하는지만 확인
- O(m): m은 문자열의 길이

### delete(word): 문자열을 Trie에서 삭제

- 문자열을 순회하며 재귀적으로 노드를 탐색하고 삭제
- O(m): m은 문자열의 길이

### getWordsWithPrefix(prefix): 특정 문자열(접두사)로 시작하는 모든 단어 반환

- 접두사 노드까지 이동한 후, DFS를 활용해 모든 완성된 단어를 배열에 담아 반환
- 시간복잡도: O(p + k \* l)
  - p: prefix 길이: 접두사까지 일단 순회하고나서 자식 노드들을 탐색하므로
  - k: 접두사로 시작하는 단어 갯수
  - l: 단어들의 평균 길이
