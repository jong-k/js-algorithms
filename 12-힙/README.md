# 힙(Heap)

> 이진 힙(Binary Heap), 우선순위 큐(Priority Queue)

- 힙은 트리의 일종
- 여러가지 힙이 존재
- 주로 우선순위 큐를 만들기 위해 쓰인다

## 1. 이진 힙(Binary Heap)

일반적으로 힙이라고 하면 이진 힙을 가리킴 (트리와 이진 트리의 관계와 유사)

이진 힙은 이진 탐색 트리와 비슷하나 몇 가지 다른 점이 있다

- 최대 이진 힙(Max Binary Heap): 부모 노드는 언제나 자식 노드보다 크다
- 최소 이진 힙(Min Binary Heap): 부모 노드는 언제나 자식 노드보다 작다

### 최대 이진 힙

- 모든 부모 노드는 최대 2개의 자식 노드를 가진다
- 모든 부모 노드의 값은 항상 자식 노드의 값보다 크다
- 형제 노드들끼리는 규칙이 없다(왼쪽, 오른쪽 순서 상관없음)
- 왼쪽 자식 노드가 먼저 채워지고 나서야 오른쪽 자식 노드가 채워진다

### 최소 이진 힙

- 최대 이진힙과 기본적으로 동일하며, 모든 부모가 항상 자식 노드보다 작은 값을 가짐

### 이진 힙에서 인덱스로 부모 노드, 자식 노드 인덱스 찾는 공식

- 인덱스를 기준으로 트리를 그리면

```js
//               0
//         1          2
//    3       4    5      6
//  7  8   9  10 11 12  13 14
```

- 다음과 같은 공식이 성립한다
  - 왼쪽 자식노드 인덱스 = 부모노드 인덱스 \* 2 + 1
  - 오른쪽 자식노드 인덱스 = 부모노드 인덱스 \* 2 + 2
  - 부모 노드 인덱스 = Math.floor((자식 노드 인덱스 - 1) / 2)

### 최대 힙 구현

- 이진 트리와 다르게 Node 클래스를 구현하지 않고 일반 배열에 값을 넣는 구조를 사용
- 최대 힙에 값을 추가할 때 특별한 메서드(Bubble Up) 필요
  - 모든 부모가 모든 자식보다 커야 하는 구조를 유지하기 위해
  - 가장 마지막에 추가된 노드가 부모 노드보다 크다면 Bubble Up을 통해 맞는 자리로 바꿔줘야 함

insert(val): 최대 힙(배열)에 새로운 값을 추가하고 적합한 위치로 이동

- 예시
- 우선 (배열에) push 후 bubble up을 통해 맞는 자리를 찾아간다

```js
// [41, 39, 33, 18, 27, 12]
//
// 55 노드를 삽입하려고 한다
// 순서를 지키며 일단 빈 곳에 새 노드를 삽입한다
//        41
//   39        33
// 18  27    12   (55)

// 1단계 bubble up
//        41
//   39        55
// 18  27    12   33
//
// 2단계 bubble up
//        55
//   39        41
// 18  27    12   33
```

bubbleUp()

- index 변수를 생성하고 배열의 최대 인덱스 값을 저장(일단 새 노드를 추가하면 가장 마지막에 배치하기 때문)
- parentIndex 변수를 생성하고 index값의 부모 노드 인덱스값 부여
  - Math.floor((index - 1) / 2)
  - 새 노드값이 부모 노드보다 작다면 계속 swap

Extract Max

- 힙에서 루트 노드를 제거하고 최근에 추가된 노드로 교체 후 sink down
- 예시

```js
// 1. 원래 힙
// [41, 39, 33, 18, 27, 12]

//         41
//     39      33
//   18  27   12

// 2. 루트 제거후 최근에 추가된 노드로 교체 -> 쉽게 뽑아낼 값이 이것 뿐임
// [12, 39, 33, 18, 27]

//         12
//     39      33
//   18  27

// 3. sink down (bubble down 이라고도 함)
// [39, 12, 33, 18, 27]

//         39  -> 12 와 39  (39가 33보다 커서)
//     12      33
//   18  27

// 반복
// [39, 27, 33, 18, 12]

//         39
//     27      33
//   18  12   <- 27과 12 swap (27이 18보다 커서)
```

sinkDown(): 새로운 루트값을 올바른 위치로 내려가면서 자리잡게 함

- 배열의 첫 번째 값(루트)과 마지막 값을 swap
- 마지막 값을 pop() 하고 모든 동작이 끝난 후 반환하기 위해 저장
- parentIndex 변수에 0(루트 인덱스) 저장
  - 왼쪽 자식 노드가 있는 경우, 왼쪽 자식 노드와 크기 비교
    - leftIndex: 2 \* parentIndex + 1
  - 오른쪽 자식 노드가 있는 경우, 오른쪽 자식 노드와 크기 비교
    - rightIndex: 2 \* parentIndex + 2
  - left나 right가 element보다 크면, 둘 중 큰 값과 swap
  - parentIndex 업데이트
  - 어떤 child도 element보다 크지 않을 때까지 반복
- 기존 root element 반환

## 2. 우선순위 큐(Priority Queue)

- 각 요소가 그에 해당하는 우선순위를 갖는 데이터 구조
- 더 높은 우선순위를 가진 요소가 더 낮은 우선순위를 가진 요소보다 먼저 처리됨
- 모든 요소가 우선순위를 갖는데, 우선순위 숫자가 낮을 수록 더 높은 우선순위임을 의미

### 구현

- 개별 노드는 value와 priority 프로퍼티를 가짐
- 우선순위(priority) 프로퍼티를 사용하여 정렬
- value는 정렬 시 중요하지 않음
- 최소 이진 힙을 사용하여 우선순위가 빠른(숫자가 작은) 것을 root로 배치

enqueue(priority, val): 새 노드를 큐에 추가하여 우선순위에 따라 적절한 자리에 배치

- 최소 힙을 재정렬

dequeue(): 루트 노드(우선순위가 가장 높은 노드)를 제거하고 반환

- 최소 힙을 재정렬

### 이진 힙의 시간 복잡도

- 삽입 : O(logN)
- 삭제 : O(logN)
- 탐색 : O(N)

이진 힙은 탐색은 불리한 편이므로, 탐색은 이진 탐색 트리를 쓰는 것이 합리적
