# 배열과 객체의 성능 평가

## 1. 객체의 Big O

### 객체를 언제 쓸까?

- 정렬되어 있을 필요가 없을 때
- 값의 접근, 삽입, 제거를 빠르게 하고 싶을 때
  - 삽입: O(1)
  - 제거: O(1)
  - 검색: O(N) -> 어떤 정보가 값에 있는지를 확인(모든 필드 확인)
  - 접근: O(1)
- 객체의 시작, 중간, 끝에 값을 집어넣을 수 없다. 단지 key를 통해 접근한다.

### 객체의 주요 메서드와 시간복잡도

- `Object.keys` : O(N)
- `Object.values` : O(N)
- `Object.entries` : O(N)
  - [[키, 밸류], [키, 밸류], ... ] 형태로 반환
- `hasOwnProperty` : O(1)
  - object.hasOwnProperty('키 이름') 형태로 사용하며 해당 프로퍼티의 존재 여부를 boolean 형태로 반환

## 2. 배열의 Big O

### 배열은 언제 쓸까?

- 정렬이 필요할 때
- 맨 마지막에 추가하거나 값을 삭제하는 것은 빠름
  - 삽입: O(1) : 어디에 삽입하는지에 따라 다름
    - 맨 뒤에 추가할 때(push) : O(1)
    - 맨 앞에 추가할 때(unshift) : O(N)
  - 제거: O(1) : 어떤 값을 제거하는지에 따라 다름
    - 맨 마지막 값을 제거할 때(pop) : O(1)
    - 맨 앞 값을 제거할 때(shift) : O(N)

#### 그래서, push, pop 보다 shift, unshift가 훨씬 느리다 (인덱스 새로 정리)

- 검색: O(N) -> 객체와 동일(모든 엘리먼트 확인)
- 접근: O(1) -> 객체와 동일

### 배열의 주요 메서드와 시간복잡도

- `concat` : O(N)
- `slice` : O(N)
  - 배열 일부를 가져옴
- `splice` : O(N)
- `sort` : O(N \* logN)
- `forEach/map/filter/reduce` : O(N)
