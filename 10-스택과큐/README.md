# 스택 & 큐

## 1. 스택

- LIFO(Last In First Out) 자료 구조
  - 후입 선출
- 접시를 쌓는 것을 생각하면 됨
- 연결 리스트를 사용하여 구현

### 사용 사례

- 콜스택 (함수 호출 관리)
- 포토샵의 `Undo` / `Redo` (`Crtl + z`)
  - 가장 마지막 작업을 취소
- 라우팅 (이전 페이지, 앞 페이지 이동)

### 구현

- 몇몇 프로그래밍 언어에서는 이미 스택이 구현되어 있으나
  - JavaScript에서는 직접 구현해야 한다
- 일반적으로는 단일 연결 리스트로 스택을 구현
  - 배열은 데이터 규모 작을때만 사용
- 단일 연결 리스트에서 구현한 push 메서드를 그대로 쓰면 tail까지 찾아가는 과정에서 O(N) 복잡도 소요됨
  - 복잡도를 O(1)로 만들기 위해 push 메서드를 직접 구현한다
  - unshift 메서드를 사용(O(1)로 동작하게 하기 위해)

push(val): 스택에 원소를 추가하고 size 반환 (SLL의 unshift와 유사)

- val 값을 갖는 새 노드 생성
- 스택이 빈 경우, first, last에 새 노드를 할당
- 스택이 차 있는 경우, 새 노드를 first에 할당하고 새 노드의 next에 기존 first를 연결
- size 1 증가하고 반환

pop(): 스택에 가장 마지막으로 추가된 노드를 제거하고 제거된 노드를 반환 (SLL의 shift와 유사)

- 빈 스택의 경우 null 반환
- 기존 first를 변수에 저장
- 스택의 크기가 1인 경우 first와 last를 null로 할당
- 스택의 크기가 2이상인 경우 기존 first의 next를 새 first로 만듬
- size 1 감소
- 기존 first 반환

### 시간 복잡도

- 삽입 : O(1)
- 제거 : O(1) -> SLL의 pop 대신 shift와 동일하게 만들었기 때문에
- 탐색 : O(N)
- 접근 : O(N)
- 탐색이나 접근에 어울리지 않음 -> 탐색이나 접근이 중요할 때는 배열을 사용
- 스택은 삽입과 제거를 중요시 한다

## 2. 큐

- FIFO(First In First Out) 자료 구조
  - 선입 선출
- 일렬로 줄서는 것을 생각하면 됨
- 연결 리스트를 사용하여 구현

### 사용 사례

- 서버 접속 대기열
- 프린트 대기열

### 구현

- 몇몇 프로그래밍 언어에서는 이미 큐가 구현되어 있으나
  - JavaScript 에서는 직접 구현해야 한다
- 일반적으로는 단일 연결 리스트로 큐를 구현
  - 배열은 데이터 규모 작을때만 사용
- deque(덱): 큐와 스택이 합쳐진 형태로, 양 끝단에서 삽입, 삭제가 가능한 자료구조

enqueue(val): 큐에 노드를 추가하고 사이즈 반환

- 새 노드를 생성
- 큐가 비었을 경우, 새 노드를 first, last로 지정
- 사이즈 1 증가하고 반환

dequeue(): 큐에서 가장 오래된 노드를 제거하고 제거된 노드를 반환

- 큐가 비었을 경우 null 반환
- first 노드를 임시 변수에 할당
- 큐의 크기가 1인 경우, 제거 후 first, last null로 변경
- 큐의 크기가 2이상인 경우, 기존 first 노드의 next 노드를 새로운 first로 할당
- 사이즈 1 감소하고 제거된 노드 반환

### 시간 복잡도

스택과 동일

- 삽입 : O(1)
- 제거 : O(1)
- 탐색 : O(N)
- 접근 : O(N)

## 3. 기타 알고리즘

### 스택 2개로 큐 구현하기

스택 2개로 큐를 구현할 수 있다

- 세부 조건: enqueue, dequeue 메서드를 갖는 큐를 스택 2개로 구현하기

구현

- 스택1에는 enqueue 시에 순서대로 push 한다
- 스택2는 dequeue 시 사용한다
  - 스택1에 있는 원소를 pop 하고 스택2에 넣는다
  - 이를 스택1이 빌 때까지 반복
  - 마지막으로 스택2의 원소를 pop 하면 dequeue 구현 가능
- ./queueWithTwoStacks.js 참조
